'use strict';
var WebSocket = require('ws');
var request = require("request");
var requireNew = require('require-new');
var jsonfile = require('jsonfile');
var fs = require('fs');
const throttle = require('throttle-function');
var parent;
var pingInterval;
var configDir = process.cwd()+"/config";
var fileRoomsJs = "/config.rooms.js";
var fileRoomsJsDebug = "/config.roomsDebug.js";
var ticket_string = ""; var privateRooms = []; var checkIfEmptyTimer;
var conecting = false;
var logParams = { fileNamePrefix:"fchat-" };
var log = require('noogger').init(logParams);
var mensaje_de_status = "Main room! [session=Lewd Sexual Wrestling - The sexfight club!]adh-5b5393f9514b3c25ab71[/session], [url=https://sexfightclub.wordpress.com/]Official blog![/url] [url=https://discord.gg/HrW2RXF]Discord room (to contact me, Kenia)[/url]";

var Discord = require('discord.io'); var bot = {conected: false};
var auth = { token: "NDk1OTMzNzk2NzQzMzgwOTky.XOykmQ.SAQnUYEQN2zUuh1x83KT5xPBnNA" };
//var discordRelayRoom = "496128161533394944";
// rough [session=Virtual Fight Arena - Dice, Ryona, Rape, Bad endings]adh-730b2671384a88f6e578[/session][session=Lewd Sexual Wrestling - Rough combat room]adh-1fbc3bb1cc55e5261aa8[/session]
var discordRooms = [
	{flist: "adh-5b5393f9514b3c25ab71", discord: "496128161533394944"},
	{flist: "adh-ab26b5c3fd556ff4384b", discord: "499368861687349248"},
	{flist: "adh-6901886fee30cce8e3d5", discord: "499368897846181902"},
	{flist: "adh-6ae1b143ac4fb9c5eeb7", discord: "499371742159044668"},
	{flist: "adh-c1ca2804565e31a32513", discord: "499434928468131841"},
	{flist: "adh-8fc13811ecd4294cc145", discord: "503793717354954753"},
	{flist: "adh-730b2671384a88f6e578", discord: "505092247315021825"},
	{flist: "adh-cbbdce8a953436b609a9", discord: "514147719955349507"},
	{flist: "adh-39fb9ed76531d838b536", discord: "518889374847336449"},
	];
var discordPrivateRoom = "496133331252019200";

class FChatLib {
	
	addJoinListener(fn){
		parent.removeJoinListener(fn);
		parent.joinListeners.push(fn);
	}
	
	removeJoinListener(fn){
		let id = parent.joinListeners.indexOf(fn)
		if (id != -1) {
			parent.joinListeners.splice(i,1);
		}
	}
	
	addModListener(fn){
		parent.removeModListener(fn);
		parent.channelModListeners.push(fn);
	}
	
	removeModListener(fn){
		let id = parent.channelModListeners.indexOf(fn)
		if (id != -1) {
			parent.channelModListeners.splice(i,1);
		}
	}
	
	addConnectionListener(fn){
        parent.removeConnectionListener(fn);
        parent.connectionListeners.push(fn);
    }

    removeConnectionListener(fn){
        let id = parent.connectionListeners.indexOf(fn);
        if(id != -1){
            parent.connectionListeners.splice(id,1);
        }
    }

    addInitialChannelDataListener(fn){
        parent.removeInitialChannelDataListener(fn);
        parent.initialChannelDataListeners.push(fn);
    }

    removeInitialChannelDataListener(fn){
        let id = parent.initialChannelDataListeners.indexOf(fn);
        if(id != -1){
            parent.initialChannelDataListeners.splice(id,1);
        }
    }

    addMessageListener(fn){
        parent.removeMessageListener(fn);
        parent.messageListeners.push(fn);
    }

    removeMessageListener(fn){
        let id = parent.messageListeners.indexOf(fn);
        if(id != -1){
            parent.messageListeners.splice(id,1);
        }
    }

    addPrivateMessageListener(fn){
        parent.removePrivateMessageListener(fn);
        parent.privateMessageListeners.push(fn);
    }

    removePrivateMessageListener(fn){
        let id = parent.privateMessageListeners.indexOf(fn);
        if(id != -1){
            parent.privateMessageListeners.splice(id,1);
        }
    }

    constructor(options){
        this.config = {};
        this.config.username = "";
        this.config.password = "";
        this.config.character = "";
        this.config.master = "";
        this.config.cname = "";
        this.config.cversion = "";

        if(typeof options !== 'object'){
            console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
            process.exit();
        }
        else{
            this.config = options;
            if(this.config.username == undefined || this.config.username == "" || this.config.password == undefined || this.config.password == "" || this.config.character == undefined || this.config.character == "" || this.config.master == undefined || this.config.master == ""){
                console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
                process.exit();
            }
        }
		
        this.connectionListeners = [];
		this.initialChannelDataListeners = [];
        this.messageListeners = [];
        this.pingListeners = [];
        this.privateMessageListeners = [];
        this.commandHandlers = [];
		this.channelModListeners = [];
		this.joinListeners = [];

        this.channels = {};
		if (this.config.rooms == "normal") {
			if (this.config.discord == "true") { this.connectDiscord(); console.log("INTENTANDO CONECTAR A DISCORD"); }
			try {
				if (fs.statSync(configDir+fileRoomsJs)) {
					this.channels = jsonfile.readFileSync(configDir+fileRoomsJs);
				}
			}
			catch(err){
				log.error("Error: "+err);
			}
		} else {
			try {
				if (fs.statSync(configDir+fileRoomsJsDebug)) {
					this.channels = jsonfile.readFileSync(configDir+fileRoomsJsDebug);
				}
			}
			catch(err){
				log.error("Error: "+err);
			}
		}
		
        if(this.config.room !== undefined && Object.keys(this.channels).indexOf(this.config.room) == -1){
            this.channels[this.config.room] = {plugins: []};
            this.updateRoomsConfig(this.channels);
        }


        this.ws = "";
        this.setFloodLimit(2);
        parent = this;

        this.generateCommandHandlers();
        this.addMessageListener(this.commandListener); //basic commands + plugins loader, one instance for one bot
		

        this.addConnectionListener(this.joinChannelOnConnect);
		this.addJoinListener(this.joinListener);
		
		this.onlineUsers = {};
		this.roomMods = {};
		this.addModListener(this.modListener);
        this.connect();
		
    }
	
	modListener(parent, data){
		parent.roomMods[data.channel] = data.oplist;
	}
	
	joinListener(parent, argument){
		if (argument.title.substr(0, 17) == "Private ring for ") {			
			if (argument.character.identity == parent.config.character) {
				let users = argument.title.substr(17).split(" and ");
				parent.sendWS("CIU", { channel: argument.channel, character: users[0] });
				parent.sendWS("CIU", { channel: argument.channel, character: users[1] });
				parent.sendPrivMessage(users[0], "[session="+argument.title+"]"+argument.channel+"[/session]");
				parent.sendPrivMessage(users[1], "[session="+argument.title+"]"+argument.channel+"[/session]");
				let commandHandler = requireNew('./commands.js');
				commandHandler(parent, { message: "!loadplugin2 BF", character: "this is a command sent by the bot itself" }, argument.channel, parent.config.debug);
				parent.commandHandlers[argument.channel] = commandHandler;
				privateRooms.push({name: argument.channel, users: [], title: argument.title});
				checkIfEmptyTimer = setInterval(function () { parent.checkIfEmpty(); }, 300000);
			} else {
				for (var i = 0; i < privateRooms.length; i++) {
					if (privateRooms[i].name == argument.channel) {
						privateRooms[i].users.push(argument.character.identity);
						log.info(argument.character.identity+" joined the room "+argument.title);
					}
				}
			}
		}
	}
	
	logPrivateRooms() {
		console.log(privateRooms);
	}
	
	leaveListener(argument) {
		if (argument.character == parent.config.character) { return 0; }
		//let check = false;
		for (let i = (privateRooms.length-1); i >= 0; i--) {
			for (let j = (privateRooms[i].users.length-1); j >= 0; j--) {
				if (argument.character == privateRooms[i].users[j]) {
					if (argument.channel == privateRooms[i].name || argument.channel == "meow meow") {
						privateRooms[i].users.splice(j, 1);
						log.info(argument.character+" has left the room "+privateRooms[i].title);
						//check = true;
					}
				}
			}
			/* if (privateRooms[i].users.length == 0 && check) {
				log.info("The rooom "+privateRooms[i].title+" is empty, leaving.");
				parent.sendWS("LCH", { channel: privateRooms[i].name });
				delete parent.commandHandlers[privateRooms[i].name];
				privateRooms.splice(i);
			} */
		}
	}
	
	checkIfEmpty() {
		for (let i = (privateRooms.length-1); i >= 0; i--) {
			if (privateRooms[i].users.length == 0) {
				log.info("The rooom "+privateRooms[i].title+" was empty for more than 5 minutes, leaving.");
				parent.sendWS("LCH", { channel: privateRooms[i].name });
				delete parent.commandHandlers[privateRooms[i].name];
				privateRooms.splice(i);
			}
		}
		if (privateRooms.length == 0) {
			clearInterval(checkIfEmptyTimer);
		}
	}
	
	joinNewChannel(channel, newPlugin){
        if(Object.keys(parent.channels).indexOf(channel) == -1){
            parent.channels[channel] = {plugins: []};
        }
        parent.sendWS('JCH', { channel: channel });
        let commandHandler = requireNew('./commands.js');
        parent.commandHandlers[channel] = commandHandler;
        //save file for rooms
        parent.updateRoomsConfig(parent.channels);
    }

    generateCommandHandlers() {
        //create one commandHandler per room
        Object.keys(parent.channels).forEach(function (room) {
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room, parent.config.rooms);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    setFloodLimit(delay){
        this.floodLimit = delay;
        this.sendData = throttle(this.sendWS, {
            window: this.floodLimit,
            limit: 1
        });
    }

    joinChannelOnConnect() {
        Object.keys(parent.channels).forEach(function(room){
            parent.sendWS('JCH', { channel: room });
        });
		setTimeout(parent.setStatus, 1000);
    }
	
	setStatus() {
		parent.sendWS('STA', { status: "online", statusmsg: mensaje_de_status });
	}

    commandListener(parent, args, chanName) {
        if(typeof parent.commandHandlers[args.channel] !== "undefined")
        {
            try {
                parent.commandHandlers[args.channel](parent, args, chanName);
            }
            catch(ex){
                console.log(ex);
                parent.throwError(args, ex.toString());
            }
        }
    }

    throwError(args, error, chan){
        log.error("Error: Please message "+parent.config.master+" with the following content:\n Error at "+new Date().toLocaleString()+" on command "+JSON.stringify(args)+" in channel "+args.channel+" with error: "+JSON.stringify(error));
    }

	connect() {
        request.post({ url: 'https://www.f-list.net/json/getApiTicket.php', form: { account: parent.config.username, password: parent.config.password } }, function (err, httpResponse, body) {
			if (body == undefined || body[0] != "{") { 
				console.log("No response from getApiTicket");
				setTimeout(parent.connect, 15000);
				return 0;
			}
			console.log("Ticket adquired from getApiTicket, attempting to start WS");
			let response = JSON.parse(body);
            let ticket = response.ticket;
            var json = { "method": "ticket", "account": parent.config.username, "ticket": ticket, "character": parent.config.character, "cname": parent.config.cname, "cversion": parent.config.cversion };
			parent.startWebsockets(json);
        });
    }
	
	connectDiscord() {
		bot = new Discord.Client({ token: auth.token });
		bot.connect();
		bot.on('ready', function (evt) {
			console.log('Connected, logged in as: '+bot.username + ' - (' + bot.id + ')');
		});
		bot.on('message', function (user, userID, channelID, message, evt) {
			if (channelID == "495737115225751564" || channelID == "507640768941260830" || channelID == "592039380869185563" || channelID == "592039513757319197") { return 0; }
			if (user != "Bot Announcer") {
				let userNick = bot.servers["495737115225751562"].members[userID].nick;
				if (userNick == undefined) { userNick = user; }
				parent.sendMessage2(userNick+": "+message, getFlistRoom(channelID));
			}
		});
		bot.on('disconnect', function(error, code) { setTimeout(bot.connect, 10000); });
	}
	
    sendWS(command, object) {
        if (parent.ws.readyState === WebSocket.OPEN) {
			parent.ws.send(command + ' ' + JSON.stringify(object));
			if (parent.config.debug == "true") { console.log(">> " + command + ' ' + JSON.stringify(object)); }
		}
	}
	
	sendCommand(command, object) {
		parent.sendData(command, object);
	}						   

    sendMessage(message, channel){
        let json = {}; if (typeof message !== 'string') { message = JSON.stringify(message); }
        json.channel = channel;
        json.message = message;
        parent.sendData('MSG', json);
		log.msg("Bot: " + message);
		if (bot.connected) { bot.sendMessage({ to: getDiscordRoom(channel), message: fixBbcode(message) }); }
		json.publico = true;
		json.character = parent.config.character;
		//console.log("from the sendMessage section: "+JSON.stringify(json)+" "+channel);
		for (var i in parent.messageListeners) {
			parent.messageListeners[i](parent, json, channel);
		}
    }
	
	sendMessage2(message, channel){
        let json = {};
        json.channel = channel;
        json.message = message;
        parent.sendData('MSG', json);
		log.msg("Bot: " + message);
    }
	
	sendDescription(description, channel) {
		let json = {};
		json.channel = channel;
		json.description = description;
		parent.sendData("CDS", json);
		log.msg("Room description:\n"+description);
	}

    sendPrivMessage(character, message){
        let json = {}; if (typeof message !== 'string') { message = JSON.stringify(message); }
        json.message = message;
        json.recipient = character;
        parent.sendData('PRI', json);
		log.pri("Bot to " + character + ":" + message);
		if (bot.connected) { bot.sendMessage({ to: discordPrivateRoom, message: "Bot to " + character + ":" + fixBbcode(message) }); }
    }
	
    restart(){
        this.ws.close();
        process.exit();
    }

    softRestart(){
		parent.privateMessageListeners = [];
		parent.commandHandlers = [];
        Object.keys(parent.channels).forEach(function (room) {
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room, parent.config.debug);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    updateRoomsConfig(channels){
        if (!fs.existsSync(configDir)){
            fs.mkdirSync(configDir);
        }
        //jsonfile.writeFile(configDir+fileRoomsJs, channels, function(err) { console.log(err); });
    }
	
	debuggy(stuff) {
		return eval(stuff);
	}
	
	
	
    startWebsockets(json) {
		//console.log("startWebsockets executing already: "+conecting);
		if (conecting == true) { return 0; }
		conecting = true;
        if (this.config.debug == "true") {
            this.ws = new WebSocket('ws://chat.f-list.net:8722');
        }
        else {
            this.ws = new WebSocket('wss://chat.f-list.net/chat2');
        }

        this.ws.on('open', function(test) {
			console.log("WS open");
            parent.sendWS('IDN', json);
        });

        this.ws.on('close', function(test) {
            console.log("WS close");
			clearInterval(pingInterval);
			setTimeout(parent.connect, 15000);
			conecting = false;
        });

        this.ws.on('error', function(test) {
            console.log("WS error");
			clearInterval(pingInterval);
            setTimeout(parent.connect, 15000);
			conecting = false;
        });

        this.ws.on('message', function (data, flags) {
			//console.log("<< "+data);
            clearInterval(pingInterval);
			pingInterval = setInterval(function () { console.log("The server has taken more than 40 seconds to send any messages, attempting to reconnect"); parent.ws.close(); }, 40000);
            if (data != null) {
                this.command = this.argument = "";
                this.command = splitOnce(data, " ")[0].trim();
                try{
                    this.argument = JSON.parse(data.substring(this.command.length).trim());
					if (this.argument.channel) { this.argument.channel = this.argument.channel.toLowerCase(); }
                }
                catch (e) {
                } let dontShow = ["LIS","FRL","VAR","STA","NLN","FLN","PIN","ADL","IGN","COL","CDS"];
				if (parent.config.rooms == "debug") { if (dontShow.indexOf(this.command) == -1) { console.log("<< "+data); } }
                switch (this.command) {
					case "COL":
						for (var i in parent.channelModListeners) {
							parent.channelModListeners[i](parent, this.argument);
						}
						break;
					case "LIS":
						let temp = this.argument.characters;
						for (let i = 0; i < temp.length; i++) {
							let chara = temp[i];
							//console.log(chara[0]);
							parent.onlineUsers[chara[0]] = {gender: chara[1], status: chara[2], statusMessage: chara[3]};
						}
						break;
					case "STA": //STA { status: "status", character: "channel", statusmsg:"statusmsg" }
                        //for (var i in parent.statusListeners) {
                        //    parent.statusListeners[i](parent, this.argument);
                        //}
						try {
							parent.onlineUsers[this.argument.character].status = this.argument.status;
							parent.onlineUsers[this.argument.character].statusMessage = this.argument.statusmsg;
						} catch (e) {}
                        break;
					case "NLN":
                        //for (var i in parent.onlineListeners) {
                        //    parent.onlineListeners[i](parent, this.argument);
                        //}
                        parent.onlineUsers[this.argument.identity] = {gender: this.argument.gender, status: this.argument.status, statusMessage: ""};
						break;
                    case "CON":
                        for (var i in parent.connectionListeners) {
                            parent.connectionListeners[i](parent, this.argument);
                        }
                        break;
					case "ICH":
                        for (var i in parent.initialChannelDataListeners) {
                            parent.initialChannelDataListeners[i](parent, this.argument);
                        }
                        break;
                    case "JCH":
                        for (var i in parent.joinListeners) {
                            parent.joinListeners[i](parent, this.argument);
                        }
						//parent.joinListener(this.argument);
                        break;
					case "LCH":
                        for (var i in parent.leaveListeners) {
                            parent.leaveListeners[i](parent, this.argument);
                        }
						parent.leaveListener(this.argument);
                        break;
					case "FLN":
                        for (var i in parent.leaveListeners) {
                            parent.leaveListeners[i](parent, this.argument);
                        }
						this.argument.channel = "meow meow";
						parent.leaveListener(this.argument);
						try {
							parent.onlineUsers[this.argument.character].status = "offline";
							parent.onlineUsers[this.argument.character].statusMessage = "";
						} catch (e) {}
                        break;
                    case "PIN":
                        //parent.ws.send("PIN");
						//console.log(">> PIN");
						if (parent.ws.readyState === WebSocket.OPEN) {
							parent.ws.send("PIN");
						}
						break;
                    case "PRI": //PRI { "character": string, "message": string }
                        for (var i in parent.privateMessageListeners) {
							this.argument.publico = false;
                            parent.privateMessageListeners[i](parent, this.argument);
                        }
						log.pri(this.argument.character + ": " + this.argument.message);
						if (bot.connected) { bot.sendMessage({ to: discordPrivateRoom, message: this.argument.character + ": " + this.argument.message }); }
                        break;
                    case "MSG": //MSG { "character": string, "message": string, "channel": string }
                        for (var i in parent.messageListeners) {
							this.argument.publico = true;
                            parent.messageListeners[i](parent, this.argument, this.argument.channel);
                        }
						//console.log("from the MSG section: "+JSON.stringify(this.argument)+" "+this.argument.channel);
						log.msg(this.argument.character + ": " + this.argument.message);
						if (bot.connected) { bot.sendMessage({ to: getDiscordRoom(this.argument.channel), message: this.argument.character + ": " + this.argument.message }); }
                        break;
					case "ERR":
						log.error("Number: "+this.argument.number+", Message: "+this.argument.message);
						break;
                }
            }
        });
    }
}

function splitOnce(str, delim) {
    var components = str.split(delim);
    var result = [components.shift()];
    if (components.length) {
        result.push(components.join(delim));
    }
    return result;
}

function fixBbcode (message) {
	if (typeof message !== 'string') { return JSON.stringify(message); }
	message = message.split("/").join("");
	message = message.split("[b]").join("**");
	message = message.split("[icon]").join("*");
	message = message.split("[eicon]").join("*");
	message = message.split("[color]").join("|");
	message = message.split("[color=white]").join("");
	message = message.split("[color=black]").join("|");
	message = message.split("[color=red]").join("|");
	message = message.split("[color=blue]").join("");
	message = message.split("[color=yellow]").join("");
	message = message.split("[color=green]").join("");
	message = message.split("[color=pink]").join("");
	message = message.split("[color=gray]").join("");
	message = message.split("[color=orange]").join("");
	message = message.split("[color=purple]").join("");
	message = message.split("[color=brown]").join("");
	message = message.split("[color=cyan]").join("");
	return message;
}

function getFlistRoom (discordRoom) {
	for (let i = 0; i < discordRooms.length; i++) {
		if (discordRooms[i].discord == discordRoom) { return discordRooms[i].flist; }
	}
	return "adh-5b5393f9514b3c25ab71";
}

function getDiscordRoom (flistRoom) {
	for (let i = 0; i < discordRooms.length; i++) {
		if (discordRooms[i].flist == flistRoom) { return discordRooms[i].discord; }
	}
	return discordPrivateRoom;
}

module.exports = FChatLib;
'use strict';
var WebSocket = require('ws');
var request = require("request");
var requireNew = require('require-new');
var jsonfile = require('jsonfile');
var fs = require('fs');
const throttle = require('throttle-function');
var parent;
var pingInterval;
var connectionTimeout;
var configDir = process.cwd()+"/config";
var fileRoomsJs = "/config.rooms.js";
var fileRoomsJsDebug = "/config.roomsDebug.js";
var ticket_string = ""; var privateRooms = []; var checkIfEmptyTimer;
var conecting = false;
var logParams = { fileNamePrefix:"fchat-" };
var log = require('noogger').init(logParams);
var mensaje_de_status = "Main room! [session=Lewd Sexual Wrestling - The sexfight club!]adh-5b5393f9514b3c25ab71[/session], [url=https://sexfightclub.wordpress.com/]Official blog![/url]";

var Discord = require('discord.io'); var bot = {conected: false};
var auth = { token: "NDk1OTMzNzk2NzQzMzgwOTky.XOykmQ.SAQnUYEQN2zUuh1x83KT5xPBnNA" };
//var discordRelayRoom = "496128161533394944";
// rough [session=Virtual Fight Arena - Dice, Ryona, Rape, Bad endings]adh-730b2671384a88f6e578[/session][session=Lewd Sexual Wrestling - Rough combat room]adh-1fbc3bb1cc55e5261aa8[/session]
var discordRooms = [
	{flist: "adh-5b5393f9514b3c25ab71", discord: "496128161533394944"},
	{flist: "adh-ab26b5c3fd556ff4384b", discord: "499368861687349248"},
	{flist: "adh-6901886fee30cce8e3d5", discord: "499368897846181902"},
	{flist: "adh-6ae1b143ac4fb9c5eeb7", discord: "499371742159044668"},
	{flist: "adh-c1ca2804565e31a32513", discord: "499434928468131841"},
	{flist: "adh-8fc13811ecd4294cc145", discord: "503793717354954753"},
	{flist: "adh-730b2671384a88f6e578", discord: "505092247315021825"},
	{flist: "adh-cbbdce8a953436b609a9", discord: "514147719955349507"},
	{flist: "adh-39fb9ed76531d838b536", discord: "518889374847336449"},
	{flist: "adh-a939d812e433438746b8", discord: "617872152292622369"},
	{flist: "adh-3769ad21f5b2d22c46db", discord: "746038179127230547"}
	];
var discordPrivateRoom = "496133331252019200";

class FChatLib {

	//{ listeners
	addJoinListener(fn){
		parent.removeJoinListener(fn);
		parent.joinListeners.push(fn);
	}

	removeJoinListener(fn){
		let id = parent.joinListeners.indexOf(fn)
		if (id != -1) {
			parent.joinListeners.splice(i,1);
		}
	}

	addModListener(fn){
		parent.removeModListener(fn);
		parent.channelModListeners.push(fn);
	}

	removeModListener(fn){
		let id = parent.channelModListeners.indexOf(fn)
		if (id != -1) {
			parent.channelModListeners.splice(i,1);
		}
	}

	addConnectionListener(fn){
        parent.removeConnectionListener(fn);
        parent.connectionListeners.push(fn);
    }

    removeConnectionListener(fn){
        let id = parent.connectionListeners.indexOf(fn);
        if(id != -1){
            parent.connectionListeners.splice(id,1);
        }
    }

    addInitialChannelDataListener(fn){
        parent.removeInitialChannelDataListener(fn);
        parent.initialChannelDataListeners.push(fn);
    }

    removeInitialChannelDataListener(fn){
        let id = parent.initialChannelDataListeners.indexOf(fn);
        if(id != -1){
            parent.initialChannelDataListeners.splice(id,1);
        }
    }

    addMessageListener(fn){
        parent.removeMessageListener(fn);
        parent.messageListeners.push(fn);
    }

    removeMessageListener(fn){
        let id = parent.messageListeners.indexOf(fn);
        if(id != -1){
            parent.messageListeners.splice(id,1);
        }
    }

    addPrivateMessageListener(fn){
        parent.removePrivateMessageListener(fn);
        parent.privateMessageListeners.push(fn);
    }

    removePrivateMessageListener(fn){
        let id = parent.privateMessageListeners.indexOf(fn);
        if(id != -1){
            parent.privateMessageListeners.splice(id,1);
        }
    }
	//}

    constructor(options){
		parent = this;
        this.config = {};
        this.config.username = "";
        this.config.password = "";
        this.config.character = "";
        this.config.master = "";
        this.config.cname = "";
        this.config.cversion = "";

        if(typeof options !== 'object'){
            console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
            process.exit();
        }
        else{
            this.config = options;
            if(this.config.username == undefined || this.config.username == "" || this.config.password == undefined || this.config.password == "" || this.config.character == undefined || this.config.character == "" || this.config.master == undefined || this.config.master == ""){
                console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
                process.exit();
            }
        }

        this.connectionListeners = [];
		this.initialChannelDataListeners = [];
        this.messageListeners = [];
        this.pingListeners = [];
        this.privateMessageListeners = [];
        this.commandHandlers = [];
		this.channelModListeners = [];
		this.joinListeners = [];

        this.channels = {};
		if (this.config.rooms == "normal") {
			if (this.config.discord == "true") { this.connectDiscord(); console.log("INTENTANDO CONECTAR A DISCORD"); }
			try {
				if (fs.statSync(configDir+fileRoomsJs)) {
					this.channels = jsonfile.readFileSync(configDir+fileRoomsJs);
				}
			}
			catch(err){
				log.error("Error: "+err);
			}
		} else {
			try {
				if (fs.statSync(configDir+fileRoomsJsDebug)) {
					this.channels = jsonfile.readFileSync(configDir+fileRoomsJsDebug);
				}
			}
			catch(err){
				log.error("Error: "+err);
			}
		}

		Object.keys(this.channels).forEach(function(room) { if (parent.channels[room].active == "false") { delete parent.channels[room]; }});


        if(this.config.room !== undefined && Object.keys(this.channels).indexOf(this.config.room) == -1){
            this.channels[this.config.room] = {plugins: []};
            this.updateRoomsConfig(this.channels);
        }


        this.ws = "";
        this.setFloodLimit(2);


        this.generateCommandHandlers();
        this.addMessageListener(this.commandListener); //basic commands + plugins loader, one instance for one bot


        this.addConnectionListener(this.joinChannelOnConnect);
		//this.addJoinListener(this.mainJoinListener);
		this.addJoinListener(this.privateRoomListener);
		this.addInitialChannelDataListener(this.initialChannelData);

		this.onlineUsers = {};
		this.roomMods = {};
		this.addModListener(this.modListener);
        this.connect();
		this.roomStatus = {};
    }

	modListener(parent, data){
		parent.roomMods[data.channel] = data.oplist;
	}

	mainJoinListener(parent, argument) {
		if (argument.character.identity != parent.config.character) { return 0; }
		if(Object.keys(parent.channels).indexOf(argument.channel) == -1){
            parent.channels[argument.channel] = {plugins: []};
			parent.channels[argument.channel].fresh = "true";
		}
		parent.channels[argument.channel].active = "true";
		parent.channels[argument.channel].title = argument.title;
		if (argument.title.substring(0, 8) == "Private ") {
			parent.channels[argument.channel].private = "true";

		} else {
			parent.channels[argument.channel].private = "false";
		}
		parent.updateRoomsConfig(parent.channels);
	}

	initialChannelData(parent, argument) {
		//Aqui recibo la información de todos los canales, como se llaman y que usuarios hay...
		if (parent.channels[argument.channel].private == "false") { return 0; }
		parent.channels[argument.channel].users = argument.users;
	}

	privateRoomListener(parent, argument) {
		parent.mainJoinListener(parent, argument);
		if (argument.title.substring(0, 8) != "Private ") { return 0; }
		if (argument.character.identity == parent.config.character) {
			if (parent.channels[argument.channel].fresh == "false") { return 0; } else { parent.channels[argument.channel].fresh = "false"; }
			let firstSplit = argument.title.split(" for ");
			let users = firstSplit[1].split(" and ");
			parent.sendData("CIU", { channel: argument.channel, character: users[0] });
			parent.sendData("CIU", { channel: argument.channel, character: users[1] });
			parent.sendPrivMessage(users[0], "[session="+argument.title+"]"+argument.channel+"[/session]");
			parent.sendPrivMessage(users[1], "[session="+argument.title+"]"+argument.channel+"[/session]");
			let commandHandler = requireNew('./commands.js');
			parent.commandHandlers[argument.channel] = commandHandler;


			if (argument.title.substr(0, 17) == "Private ring for ") {
				commandHandler(parent, { message: "!loadplugin2 BF", character: "this is a command sent by the bot itself" }, argument.channel, parent.config.debug);
			}
			if (argument.title.substr(0, 26) == "Private magical arena for ") {
				commandHandler(parent, { message: "!loadplugin2 MagicalArena", character: "this is a command sent by the bot itself" }, argument.channel, parent.config.debug);
			}

		} else {
			parent.channels[argument.channel].users.push(argument.character);
			log.info(argument.character.identity+" joined the room "+argument.title);
		}
	}


	logPrivateRooms() {
		console.log(JSON.stringify(parent.channels));
	}

	leaveListener(argument) {
		if (argument.character == parent.config.character) { return 0; }
		if (argument.channel == "meow meow") {
			Object.keys(parent.channels).forEach(function(room) {
			if (parent.channels[room].private == "false") { return 0; }
				if (parent.channels[room].users == null) { return 0; }
				parent.channels[room].users.forEach(function(user, index) {
					if (parent.channels[room].users[index].identity == argument.character) {
						parent.channels[room].users.splice(index, 1);
						log.info(argument.character+" has left the room "+parent.channels[room].title);
						if (parent.channels[room].users.length == 1) {
							parent.sendData("LCH", { channel: room });
							delete parent.commandHandlers[room];
							delete parent.channels[room];
							parent.updateRoomsConfig(parent.channels);
							log.info("Room empty, deleting");
						}
					}
				});
			});

		} else {
			if (parent.channels[argument.channel].private == "false") { return 0; }
			parent.channels[argument.channel].users.forEach(function(user, index) {
				if (user.identity == argument.character) {
					log.info(argument.character+" has left the room "+parent.channels[argument.channel].title);
					parent.channels[argument.channel].users.splice(index, 1);
					if (parent.channels[argument.channel].users.length == 1) {
						parent.sendData("LCH", { channel: argument.channel });
						delete parent.commandHandlers[argument.channel];
						delete parent.channels[argument.channel];
						parent.updateRoomsConfig(parent.channels);
						log.info("Room empty, deleting");
					}
				}
			});
		}
	}

	checkIfEmpty() {
		Object.keys(parent.channels).forEach(function(room) {
			if (parent.channels[room].private == "false") { return 0; }
			if (parent.channels[room].users == null || parent.channels[room].users.length == 1) {
				log.info("The rooom "+parent.channels[room].title+" was empty for more than 5 minutes, leaving.");
				if (parent.channels[room].active == "true") {  }
				delete parent.commandHandlers[parent.channels[room].name];
				delete parent.channels[parent.channels[room].name];
				parent.updateRoomsConfig(parent.channels);
			}
		});
	}

	joinNewChannel(channel, newPlugin){
        if(Object.keys(parent.channels).indexOf(channel) == -1){
            parent.channels[channel] = {plugins: []};
        }
        parent.sendData('JCH', { channel: channel });
        let commandHandler = requireNew('./commands.js');
        parent.commandHandlers[channel] = commandHandler;
        //save file for rooms
        parent.updateRoomsConfig(parent.channels);
    }

    generateCommandHandlers() {
        //create one commandHandler per room
        Object.keys(parent.channels).forEach(function (room) {
			if (parent.channels[room].active == "false") { return 0; }
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room, parent.config.rooms);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    setFloodLimit(delay){
        this.floodLimit = delay;
        this.sendData = throttle(this.sendWS, {
            window: this.floodLimit,
            limit: 1
        });
    }

    joinChannelOnConnect() {
        Object.keys(parent.channels).forEach(function(room){
			if (parent.channels[room].active == "false") { return 0; }
			if (parent.channels[room].title.substring(0, 8) == "Private ") {
				parent.channels[room].active = "false";
			}

			parent.sendData('JCH', { channel: room });
        });
		setTimeout(parent.setStatus, 1000);
    }

	setStatus() {
		parent.sendData('STA', { status: "online", statusmsg: mensaje_de_status });
	}

    commandListener(parent, args, chanName) {
        if(typeof parent.commandHandlers[args.channel] !== "undefined")
        {
            try {
                parent.commandHandlers[args.channel](parent, args, chanName);
            }
            catch(ex){
                console.log(ex);
                parent.throwError(args, ex.toString());
            }
        }
    }

    throwError(args, error, chan){
        log.error("Error: Please message "+parent.config.master+" with the following content:\n Error at "+new Date().toLocaleString()+" on command "+JSON.stringify(args)+" in channel "+args.channel+" with error: "+JSON.stringify(error));
    }

	connect() {
		if (conecting == true) { console.log("Already connecting... 1"); return 0; }
        request.post({ url: 'https://www.f-list.net/json/getApiTicket.php', form: { account: parent.config.username, password: parent.config.password } }, function (err, httpResponse, body) {
			if (body == undefined || body[0] != "{") {
				console.log("No response from getApiTicket");
				setTimeout(parent.connect, 15000);
				return 0;
			}
			console.log("Ticket adquired from getApiTicket, attempting to start WS");
			let response = JSON.parse(body);
            let ticket = response.ticket;
            var json = { "method": "ticket", "account": parent.config.username, "ticket": ticket, "character": parent.config.character, "cname": parent.config.cname, "cversion": parent.config.cversion };
			parent.startWebsockets(json);
        });
    }

	connectDiscord() {
		bot = new Discord.Client({ token: auth.token });
		bot.connect();
		bot.on('ready', function (evt) {
			console.log('Connected, logged in as: '+bot.username + ' - (' + bot.id + ')');
		});
		/*
		bot.on('message', function (user, userID, channelID, message, evt) {
			if (channelID == "495737115225751564" || channelID == "507640768941260830" || channelID == "592039380869185563" || channelID == "592039513757319197" || channelID == "612979306494296085") { return 0; }
			if (user != "Bot Announcer") {
				let userNick = bot.servers["495737115225751562"].members[userID].nick;
				if (userNick == undefined) { userNick = user; }
				parent.sendMessage2(userNick+": "+message, getFlistRoom(channelID));
			}
		});
		*/
		bot.on('disconnect', function(error, code) { setTimeout(bot.connect, 10000); });

		/*
		bot.on('message', function (user, userID, channelID, message, evt) {
			if (channelID == "495737115225751564" || channelID == "507640768941260830" || channelID == "592039380869185563" || channelID == "592039513757319197" || channelID == "612979306494296085") { return 0; }
			if (bot.connected) { bot.sendMessage({ to: channelID, message: "(Messages are not being relayed back to f-list, sorry)" }); }
		});
		*/
	}

    sendWS(command, object) {
        if (parent.ws.readyState === WebSocket.OPEN) {
			//if (parent.config.debug == "true") { console.log(">> " + command + ' ' + JSON.stringify(object)); }
			if (JSON.stringify(object).length > 50000) { console.log("A LOT OF CHARACTERS! WARNING!"); return 0; }
			parent.ws.send(command + ' ' + JSON.stringify(object));

		}
	}

	sendCommand(command, object) {
		parent.sendData(command, object);
	}

    sendMessage(message, channel){
        let json = {}; if (typeof message !== 'string') { message = JSON.stringify(message); }
        json.channel = channel;
        json.message = message;
        parent.sendData('MSG', json);
		log.msg("Bot: " + message);
		if (bot.connected) { bot.sendMessage({ to: getDiscordRoom(channel), message: fixBbcode(message) }); }
		json.publico = true;
		json.character = parent.config.character;
		//console.log("from the sendMessage section: "+JSON.stringify(json)+" "+channel);
		for (var i in parent.messageListeners) {
			parent.messageListeners[i](parent, json, channel);
		}
    }

	sendMessage2(message, channel){
        let json = {};
        json.channel = channel;
        json.message = message;
        parent.sendData('MSG', json);
		log.msg("Bot: " + message);
    }

	sendDescription(description, channel) {
		let json = {};
		json.channel = channel;
		json.description = description;
		parent.sendData("CDS", json);
		log.msg("Room description:\n"+description);
	}

    sendPrivMessage(character, message){
        let json = {}; if (typeof message !== 'string') { message = JSON.stringify(message); }
        json.message = message;
        json.recipient = character;
        parent.sendData('PRI', json);
		log.pri("Bot to " + character + ":" + message);
		if (bot.connected) { bot.sendMessage({ to: discordPrivateRoom, message: "Bot to " + character + ":" + fixBbcode(message) }); }
    }

    restart(){
        this.ws.close();
        process.exit();
    }

    softRestart(){
		//parent.messageListeners = [];
		parent.privateMessageListeners = [];
		parent.commandHandlers = [];
		parent.generateCommandHandlers()
		parent.addMessageListener(parent.commandListener);
    }

    updateRoomsConfig(channels){
        if (!fs.existsSync(configDir)){
            fs.mkdirSync(configDir);
        }
		if (this.config.rooms == "normal") {
			jsonfile.writeFileSync(configDir+fileRoomsJs, channels, function(err) { console.log(err); });
		} else {
			jsonfile.writeFileSync(configDir+fileRoomsJsDebug, channels, function(err) { console.log(err); });
		}
    }

	debuggy(stuff) {
		return eval(stuff);
	}



    startWebsockets(json) {
		//console.log("startWebsockets executing already: "+conecting);
		if (conecting == true) {
			console.log("Already connecting...");
			return 0;
		}
		conecting = true;
        if (this.config.debug == "true") {
            this.ws = new WebSocket('wss://chat.f-list.net/chat2'); //************************* debug
        }
        else {
            this.ws = new WebSocket('wss://chat.f-list.net/chat2');
		}

		pingInterval = setTimeout(function () { console.log("The server has taken more than 40 seconds to send any messages, attempting to reconnect"); parent.ws.close(); }, 40000);
		
        this.ws.on('open', function(test) {
			console.log("WS open");
            parent.sendWS('IDN', json);
        });

        this.ws.on('close', function(test, test2) {
            console.log("WS close");
			clearTimeout(pingInterval);
			setTimeout(()=>{parent.connect()}, 10000);
			conecting = false;
			console.log(test);
			console.log(test2);
        });

        this.ws.on('error', function(test, test2) {
            console.log("WS error");
			clearTimeout(pingInterval);
            setTimeout(()=>{parent.connect()}, 10000);
			conecting = false;
			console.log(test);
			console.log(test2);
        });

        this.ws.on('message', function (data, flags) {
			//console.log("<< "+data);
            clearTimeout(pingInterval);
			pingInterval = setTimeout(function () { console.log("The server has taken more than 40 seconds to send any messages, attempting to reconnect"); parent.ws.close(); }, 40000);
            if (data != null) {
                this.command = this.argument = "";
                this.command = splitOnce(data, " ")[0].trim();
                try{
                    this.argument = JSON.parse(data.substring(this.command.length).trim());
					if (this.argument.channel) { this.argument.channel = this.argument.channel.toLowerCase(); }
                }
                catch (e) {
                }
				//let dontShow = ["LIS","FRL","VAR","STA","NLN","FLN","PIN","ADL","IGN","COL","CDS"];
				//if (parent.config.rooms == "debug") { if (dontShow.indexOf(this.command) == -1) { console.log("<< "+data); } }
                switch (this.command) {
					case "COL":
						for (var i in parent.channelModListeners) {
							parent.channelModListeners[i](parent, this.argument);
						}
						break;
					case "LIS":
						let temp = this.argument.characters;
						for (let i = 0; i < temp.length; i++) {
							let chara = temp[i];
							//console.log(chara[0]);
							parent.onlineUsers[chara[0]] = {gender: chara[1], status: chara[2], statusMessage: chara[3]};
						}
						break;
					case "STA": //STA { status: "status", character: "channel", statusmsg:"statusmsg" }
                        //for (var i in parent.statusListeners) {
                        //    parent.statusListeners[i](parent, this.argument);
                        //}
						try {
							parent.onlineUsers[this.argument.character].status = this.argument.status;
							parent.onlineUsers[this.argument.character].statusMessage = this.argument.statusmsg;
						} catch (e) {}
                        break;
					case "NLN":
                        //for (var i in parent.onlineListeners) {
                        //    parent.onlineListeners[i](parent, this.argument);
                        //}
                        parent.onlineUsers[this.argument.identity] = {gender: this.argument.gender, status: this.argument.status, statusMessage: ""};
						break;
                    case "CON":
                        for (var i in parent.connectionListeners) {
                            parent.connectionListeners[i](parent, this.argument);
                        }
                        break;
					case "ICH":
                        for (var i in parent.initialChannelDataListeners) {
                            parent.initialChannelDataListeners[i](parent, this.argument);
                        }
                        break;
                    case "JCH":
                        for (var i in parent.joinListeners) {
                            parent.joinListeners[i](parent, this.argument);
                        }
						//parent.joinListener(this.argument);
                        break;
					case "LCH":
                        for (var i in parent.leaveListeners) {
                            parent.leaveListeners[i](parent, this.argument);
                        }
						parent.leaveListener(this.argument);
                        break;
					case "FLN":
                        for (var i in parent.leaveListeners) {
                            parent.leaveListeners[i](parent, this.argument);
                        }
						this.argument.channel = "meow meow";
						parent.leaveListener(this.argument);
						try {
							parent.onlineUsers[this.argument.character].status = "offline";
							parent.onlineUsers[this.argument.character].statusMessage = "";
						} catch (e) {}
                        break;
                    case "PIN":
                        //parent.ws.send("PIN");
						//console.log(">> PIN");
						if (parent.ws.readyState === WebSocket.OPEN) {
							parent.ws.send("PIN");
						}
						break;
                    case "PRI": //PRI { "character": string, "message": string }
                        for (var i in parent.privateMessageListeners) {
							this.argument.publico = false;
                            parent.privateMessageListeners[i](parent, this.argument);
                        }
						log.pri(this.argument.character + ": " + this.argument.message);
						if (bot.connected) { bot.sendMessage({ to: discordPrivateRoom, message: this.argument.character + ": " + this.argument.message }); }
                        break;
                    case "MSG": //MSG { "character": string, "message": string, "channel": string }
                        for (var i in parent.messageListeners) {
							this.argument.publico = true;
                            parent.messageListeners[i](parent, this.argument, this.argument.channel);
                        }
						//console.log("from the MSG section: "+JSON.stringify(this.argument)+" "+this.argument.channel);
						log.msg(this.argument.character + ": " + this.argument.message);
						if (bot.connected) { bot.sendMessage({ to: getDiscordRoom(this.argument.channel), message: this.argument.character + ": " + this.argument.message }); }
                        break;
					case "ERR":
						log.error("Number: "+this.argument.number+", Message: "+this.argument.message);
						break;
                }
            }
        });
    }
}

function splitOnce(str, delim) {
    var components = str.split(delim);
    var result = [components.shift()];
    if (components.length) {
        result.push(components.join(delim));
    }
    return result;
}

function fixBbcode (message) {
	if (typeof message !== 'string') { return JSON.stringify(message); }
	message = message.split("/").join("");
	message = message.split("[b]").join("**");
	message = message.split("[icon]").join("*");
	message = message.split("[eicon]").join("*");
	message = message.split("[color]").join("|");
	message = message.split("[color=white]").join("");
	message = message.split("[color=black]").join("|");
	message = message.split("[color=red]").join("|");
	message = message.split("[color=blue]").join("");
	message = message.split("[color=yellow]").join("");
	message = message.split("[color=green]").join("");
	message = message.split("[color=pink]").join("");
	message = message.split("[color=gray]").join("");
	message = message.split("[color=orange]").join("");
	message = message.split("[color=purple]").join("");
	message = message.split("[color=brown]").join("");
	message = message.split("[color=cyan]").join("");
	return message;
}

function getFlistRoom (discordRoom) {
	for (let i = 0; i < discordRooms.length; i++) {
		if (discordRooms[i].discord == discordRoom) { return discordRooms[i].flist; }
	}
	return "adh-5b5393f9514b3c25ab71";
}

function getDiscordRoom (flistRoom) {
	for (let i = 0; i < discordRooms.length; i++) {
		if (discordRooms[i].flist == flistRoom) { return discordRooms[i].discord; }
	}
	return discordPrivateRoom;
}

module.exports = FChatLib;

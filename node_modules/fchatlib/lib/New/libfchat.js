'use strict';
var WebSocket = require('ws');
var request = require("request");
var requireNew = require('require-new');
var jsonfile = require('jsonfile');
var fs = require('fs');
const throttle = require('throttle-function');
var parent;
var pingInterval;
var conectInterval;
var configDir = process.cwd()+"/config";
var fileRoomsJs = "/config.rooms.js";
var ticket_string = "";

var logParams = { fileNamePrefix:"fchat-" };
var log = require('noogger').init(logParams);

class FChatLib {
	
	addConnectionListener(fn){
        parent.removeConnectionListener(fn);
        parent.connectionListeners.push(fn);
    }

    removeConnectionListener(fn){
        let id = parent.connectionListeners.indexOf(fn);
        if(id != -1){
            parent.connectionListeners.splice(id,1);
        }
    }
	
	addPingListener(fn){
        parent.removePingListener(fn);
        parent.pingListeners.push(fn);
    }

    removePingListener(fn){
        let id = parent.pingListeners.indexOf(fn);
        if(id != -1){
            parent.pingListeners.splice(id,1);
        }
    }

    addInitialChannelDataListener(fn){
        parent.removeInitialChannelDataListener(fn);
        parent.initialChannelDataListeners.push(fn);
    }

    removeInitialChannelDataListener(fn){
        let id = parent.initialChannelDataListeners.indexOf(fn);
        if(id != -1){
            parent.initialChannelDataListeners.splice(id,1);
        }
    }

    addMessageListener(fn){
        parent.removeMessageListener(fn);
        parent.messageListeners.push(fn);
    }

    removeMessageListener(fn){
        let id = parent.messageListeners.indexOf(fn);
        if(id != -1){
            parent.messageListeners.splice(id,1);
        }
    }

    addPrivateMessageListener(fn){
        parent.removePrivateMessageListener(fn);
        parent.privateMessageListeners.push(fn);
    }

    removePrivateMessageListener(fn){
        let id = parent.privateMessageListeners.indexOf(fn);
        if(id != -1){
            parent.privateMessageListeners.splice(id,1);
        }
    }

    constructor(options){
        this.config = {};
        this.config.username = "";
        this.config.password = "";
        this.config.character = "";
        this.config.master = "";
        this.config.cname = "";
        this.config.cversion = "";

        if(typeof options !== 'object'){
            console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
            process.exit();
        }
        else{
            this.config = options;
            if(this.config.username == undefined || this.config.username == "" || this.config.password == undefined || this.config.password == "" || this.config.character == undefined || this.config.character == "" || this.config.master == undefined || this.config.master == ""){
                console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
                process.exit();
            }
        }
		
        this.connectionListeners = [];
		this.initialChannelDataListeners = [];
        this.messageListeners = [];
        this.pingListeners = [];
        this.privateMessageListeners = [];
        this.commandHandlers = [];

        this.channels = {};
        try {
            if (fs.statSync(configDir+fileRoomsJs)) {
                this.channels = jsonfile.readFileSync(configDir+fileRoomsJs);
            }
        }
        catch(err){}

        if(this.config.room !== undefined && Object.keys(this.channels).indexOf(this.config.room) == -1){
            this.channels[this.config.room] = {plugins: []};
            this.updateRoomsConfig(this.channels);
        }


        this.ws = "";
        this.setFloodLimit(2);
        parent = this;

        this.generateCommandHandlers();
        this.addMessageListener(this.commandListener); //basic commands + plugins loader, one instance for one bot
		

        this.addConnectionListener(this.joinChannelOnConnect);
        
        conectInterval = setInterval(function () { parent.connect(); }, 4000);
		this.addPingListener(this.sendPIN);
    }
	
	sendPIN() {
		if (parent.ws.readyState) {
			clearInterval(pingInterval);
			pingInterval = setInterval(function () { parent.ws.send('PIN'); console.log("Time out."); }, 40000);
			parent.ws.send("PIN");
			//console.log(">> PIN");
		}
	}

    generateCommandHandlers() {
        //create one commandHandler per room
        Object.keys(parent.channels).forEach(function (room) {
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    setFloodLimit(delay){
        this.floodLimit = delay;
        this.sendData = throttle(this.sendWS, {
            window: this.floodLimit,
            limit: 1
        });
    }

    joinChannelOnConnect() {
        Object.keys(parent.channels).forEach(function(room){
            parent.sendWS('JCH', { channel: room });
        });
    }

    commandListener(parent, args, chanName) {
        if(typeof parent.commandHandlers[args.channel] !== "undefined")
        {
            try {
                parent.commandHandlers[args.channel](parent, args, chanName);
            }
            catch(ex){
                console.log(ex);
                parent.throwError(args, ex.toString());
            }
        }
    }

    throwError(args, error, chan){
        console.log("Error: Please message "+parent.config.master+" with the following content:\n Error at "+new Date().toLocaleString()+" on command "+JSON.stringify(args)+" in channel "+args.channel+" with error: "+JSON.stringify(error));
    }

	connect() {
        request.post({ url: 'https://www.f-list.net/json/getApiTicket.php', form: { account: parent.config.username, password: parent.config.password } }, function (err, httpResponse, body) {
			if (body == undefined) { 
				console.log("No response from getApiTicket.");
				return 0;
			}
			let response = JSON.parse(body);
            let ticket = response.ticket;
            var json = { "method": "ticket", "account": parent.config.username, "ticket": ticket, "character": parent.config.character, "cname": parent.config.cname, "cversion": parent.config.cversion };
			parent.startWebsockets(json);
			pingInterval = setInterval(function () { parent.ws.send('PIN'); console.log("Time out"); }, 40000);
        });
    }
	
    sendWS(command, object) {
        if (parent.ws.readyState) {
			parent.ws.send(command + ' ' + JSON.stringify(object));
			//console.log(">> " + command + ' ' + JSON.stringify(object));
		}
	}
	
	sendCommand(command, object) {
		parent.sendData(command, object);
	}						   

    sendMessage(message, channel){
        let json = {};
        json.channel = channel;
        json.message = message;
        parent.sendData('MSG', json);
		log.info("Message - Bot: " + message);
    }

    sendPrivMessage(character, message){
        let json = {};
        json.message = message;
        json.recipient = character;
        parent.sendData('PRI', json);
		log.info("Private - Bot to " + character + ":" + message);
    }
	
    restart(){
        this.ws.close();
        process.exit();
    }

    softRestart(){
		parent.privateMessageListeners = [];
		parent.commandHandlers = [];
        Object.keys(parent.channels).forEach(function (room) {
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    updateRoomsConfig(channels){
        if (!fs.existsSync(configDir)){
            fs.mkdirSync(configDir);
        }
        jsonfile.writeFile(configDir+fileRoomsJs, channels);
    }


    startWebsockets(json) {
        if (this.config.debug == "true") {
            this.ws = new WebSocket('ws://chat.f-list.net:8722');
        }
        else {
            this.ws = new WebSocket('ws://chat.f-list.net:8722');
        }

        this.ws.on('open', function(test) {
            console.log("WS open");
            parent.sendWS('IDN', json);
			clearInterval(conectInterval);
        });

        this.ws.on('close', function(test) {
            console.log("WS close");
			clearInterval(pingInterval);
			conectInterval = setInterval(function () { parent.connect(); }, 4000);
        });

        this.ws.on('error', function(test) {
            console.log("WS error");
			clearInterval(pingInterval);
            conectInterval = setInterval(function () { parent.connect(); }, 4000);
        });

        this.ws.on('message', function (data, flags) {
            console.log("<< " + data.slice(0,150));
            if (data != null) {
                this.command = this.argument = "";
                this.command = splitOnce(data, " ")[0].trim();
                try{
                    this.argument = JSON.parse(data.substring(this.command.length).trim());
                }
                catch (e) {
                }
                switch (this.command) {
                    case "CON":
                        for (var i in parent.connectionListeners) {
                            parent.connectionListeners[i](parent, this.argument);
                        }
                        break;
					case "ICH":
                        for (var i in parent.initialChannelDataListeners) {
                            parent.initialChannelDataListeners[i](parent, this.argument);
                        }
                        break;
                    case "JCH":
                        for (var i in parent.joinListeners) {
                            parent.joinListeners[i](parent, this.argument);
                        }
                        break;
                    case "PIN":
                        for (var i in parent.pingListeners) {
                            parent.pingListeners[i](parent, this.argument);
                        }
                        break;
                    case "PRI": //PRI { "character": string, "message": string }
                        for (var i in parent.privateMessageListeners) {
							this.argument.publico = false;
                            parent.privateMessageListeners[i](parent, this.argument);
                        }
						log.info("Private - " + this.argument.character + ": " + this.argument.message);
                        break;
                    case "MSG": //MSG { "character": string, "message": string, "channel": string }
                        for (var i in parent.messageListeners) {
							this.argument.publico = true;
                            parent.messageListeners[i](parent, this.argument, this.argument.channel);
                        }
						log.info("Message - " + this.argument.channel + " - " + this.argument.character + ": " + this.argument.message);
                        break;
                }
            }
        });
    }
}

function splitOnce(str, delim) {
    var components = str.split(delim);
    var result = [components.shift()];
    if (components.length) {
        result.push(components.join(delim));
    }
    return result;
}

module.exports = FChatLib;
'use strict';
var WebSocket = require('ws');
var request = require("request");
var requireNew = require('require-new');
var jsonfile = require('jsonfile');
var fs = require('fs');
const throttle = require('throttle-function');
var parent;
var pingInterval;
var configDir = process.cwd()+"/config";
var fileRoomsJs = "/config.rooms.js";
var ticket_string = ""; var privateRooms = []; var checkIfEmptyTimer;
var conecting = false;
var logParams = { fileNamePrefix:"fchat-" };
var log = require('noogger').init(logParams);

class FChatLib {
	
	addConnectionListener(fn){
        parent.removeConnectionListener(fn);
        parent.connectionListeners.push(fn);
    }

    removeConnectionListener(fn){
        let id = parent.connectionListeners.indexOf(fn);
        if(id != -1){
            parent.connectionListeners.splice(id,1);
        }
    }

    addInitialChannelDataListener(fn){
        parent.removeInitialChannelDataListener(fn);
        parent.initialChannelDataListeners.push(fn);
    }

    removeInitialChannelDataListener(fn){
        let id = parent.initialChannelDataListeners.indexOf(fn);
        if(id != -1){
            parent.initialChannelDataListeners.splice(id,1);
        }
    }

    addMessageListener(fn){
        parent.removeMessageListener(fn);
        parent.messageListeners.push(fn);
    }

    removeMessageListener(fn){
        let id = parent.messageListeners.indexOf(fn);
        if(id != -1){
            parent.messageListeners.splice(id,1);
        }
    }

    addPrivateMessageListener(fn){
        parent.removePrivateMessageListener(fn);
        parent.privateMessageListeners.push(fn);
    }

    removePrivateMessageListener(fn){
        let id = parent.privateMessageListeners.indexOf(fn);
        if(id != -1){
            parent.privateMessageListeners.splice(id,1);
        }
    }

    constructor(options){
        this.config = {};
        this.config.username = "";
        this.config.password = "";
        this.config.character = "";
        this.config.master = "";
        this.config.cname = "";
        this.config.cversion = "";

        if(typeof options !== 'object'){
            console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
            process.exit();
        }
        else{
            this.config = options;
            if(this.config.username == undefined || this.config.username == "" || this.config.password == undefined || this.config.password == "" || this.config.character == undefined || this.config.character == "" || this.config.master == undefined || this.config.master == ""){
                console.log('Wrong parameters passed, you need username, password, character, master, cname and cversion.');
                process.exit();
            }
        }
		
        this.connectionListeners = [];
		this.initialChannelDataListeners = [];
        this.messageListeners = [];
        this.pingListeners = [];
        this.privateMessageListeners = [];
        this.commandHandlers = [];

        this.channels = {};
        try {
            if (fs.statSync(configDir+fileRoomsJs)) {
                this.channels = jsonfile.readFileSync(configDir+fileRoomsJs);
            }
        }
        catch(err){}

        if(this.config.room !== undefined && Object.keys(this.channels).indexOf(this.config.room) == -1){
            this.channels[this.config.room] = {plugins: []};
            this.updateRoomsConfig(this.channels);
        }


        this.ws = "";
        this.setFloodLimit(2);
        parent = this;

        this.generateCommandHandlers();
        this.addMessageListener(this.commandListener); //basic commands + plugins loader, one instance for one bot
		

        this.addConnectionListener(this.joinChannelOnConnect);
        
        this.connect();
    }
	
	joinListener(argument){
		if (argument.title.substr(0, 17) == "Private ring for ") {			
			if (argument.character.identity == "Bot Announcer") {
				let users = argument.title.substr(17).split(" and ");
				parent.sendWS("CIU", { channel: argument.channel, character: users[0] });
				parent.sendWS("CIU", { channel: argument.channel, character: users[1] });
				parent.sendPrivMessage(users[0], "[session="+argument.title+"]"+argument.channel+"[/session]");
				parent.sendPrivMessage(users[1], "[session="+argument.title+"]"+argument.channel+"[/session]");
				let commandHandler = requireNew('./commands.js');
				commandHandler(parent, { message: "!loadplugin2 BF", character: "this is a command sent by the bot itself" }, argument.channel);
				parent.commandHandlers[argument.channel] = commandHandler;
				privateRooms.push({name: argument.channel, users: [], title: argument.title});
				checkIfEmptyTimer = setInterval(function () { parent.checkIfEmpty(); }, 300000);
			} else {
				for (var i = 0; i < privateRooms.length; i++) {
					if (privateRooms[i].name == argument.channel) {
						privateRooms[i].users.push(argument.character.identity);
						log.info(argument.character.identity+" joined the room "+argument.title);
					}
				}
			}
		}
	}
	
	logPrivateRooms() {
		console.log(privateRooms);
	}
	
	leaveListener(argument) {
		if (argument.character == "Bot Announcer") { return 0; }
		//let check = false;
		for (let i = (privateRooms.length-1); i >= 0; i--) {
			for (let j = (privateRooms[i].users.length-1); j >= 0; j--) {
				if (argument.character == privateRooms[i].users[j]) {
					if (argument.channel == privateRooms[i].name || argument.channel == "meow meow") {
						privateRooms[i].users.splice(j, 1);
						log.info(argument.character+" has left the room "+privateRooms[i].title);
						//check = true;
					}
				}
			}
			/* if (privateRooms[i].users.length == 0 && check) {
				log.info("The rooom "+privateRooms[i].title+" is empty, leaving.");
				parent.sendWS("LCH", { channel: privateRooms[i].name });
				delete parent.commandHandlers[privateRooms[i].name];
				privateRooms.splice(i);
			} */
		}
	}
	
	checkIfEmpty() {
		for (let i = (privateRooms.length-1); i >= 0; i--) {
			if (privateRooms[i].users.length == 0) {
				log.info("The rooom "+privateRooms[i].title+" was empty for more than 5 minutes, leaving.");
				parent.sendWS("LCH", { channel: privateRooms[i].name });
				delete parent.commandHandlers[privateRooms[i].name];
				privateRooms.splice(i);
			}
		}
		if (privateRooms.length == 0) {
			clearInterval(checkIfEmptyTimer);
		}
	}
	
	joinNewChannel(channel, newPlugin){
        if(Object.keys(parent.channels).indexOf(channel) == -1){
            parent.channels[channel] = {plugins: []};
        }
        parent.sendWS('JCH', { channel: channel });
        let commandHandler = requireNew('./commands.js');
        parent.commandHandlers[channel] = commandHandler;
        //save file for rooms
        parent.updateRoomsConfig(parent.channels);
    }

    generateCommandHandlers() {
        //create one commandHandler per room
        Object.keys(parent.channels).forEach(function (room) {
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    setFloodLimit(delay){
        this.floodLimit = delay;
        this.sendData = throttle(this.sendWS, {
            window: this.floodLimit,
            limit: 1
        });
    }

    joinChannelOnConnect() {
        Object.keys(parent.channels).forEach(function(room){
            parent.sendWS('JCH', { channel: room });
        });
    }

    commandListener(parent, args, chanName) {
        if(typeof parent.commandHandlers[args.channel] !== "undefined")
        {
            try {
                parent.commandHandlers[args.channel](parent, args, chanName);
            }
            catch(ex){
                console.log(ex);
                parent.throwError(args, ex.toString());
            }
        }
    }

    throwError(args, error, chan){
        log.error("Error: Please message "+parent.config.master+" with the following content:\n Error at "+new Date().toLocaleString()+" on command "+JSON.stringify(args)+" in channel "+args.channel+" with error: "+JSON.stringify(error));
    }

	connect() {
        request.post({ url: 'https://www.f-list.net/json/getApiTicket.php', form: { account: parent.config.username, password: parent.config.password } }, function (err, httpResponse, body) {
			if (body == undefined || body[0] != "{") { 
				console.log("No response from getApiTicket");
				setTimeout(parent.connect, 15000);
				return 0;
			}
			console.log("Ticket adquired from getApiTicket, attempting to start WS");
			let response = JSON.parse(body);
            let ticket = response.ticket;
            var json = { "method": "ticket", "account": parent.config.username, "ticket": ticket, "character": parent.config.character, "cname": parent.config.cname, "cversion": parent.config.cversion };
			parent.startWebsockets(json);
        });
    }
	
    sendWS(command, object) {
        if (parent.ws.readyState) {
			parent.ws.send(command + ' ' + JSON.stringify(object));
			//console.log(">> " + command + ' ' + JSON.stringify(object));
		}
	}
	
	sendCommand(command, object) {
		parent.sendData(command, object);
	}						   

    sendMessage(message, channel){
        let json = {};
        json.channel = channel;
        json.message = message;
        parent.sendData('MSG', json);
		log.msg("Bot: " + message);
		json.publico = true; //////////////////////
		json.character = "Bot Announcer"; ////////////////////////////////////////////////////////////////////////////////////////////////////////
		for (var i in parent.messageListeners) { /////////////////////////
			parent.messageListeners[i](parent, json, channel); //////////////
		} //////////////////////////////////////////////////////////////
    }

    sendPrivMessage(character, message){
        let json = {};
        json.message = message;
        json.recipient = character;
        parent.sendData('PRI', json);
		log.pri("Bot to " + character + ":" + message);
    }
	
    restart(){
        this.ws.close();
        process.exit();
    }

    softRestart(){
		parent.privateMessageListeners = [];
		parent.commandHandlers = [];
        Object.keys(parent.channels).forEach(function (room) {
            let commandHandler = requireNew('./commands.js');
            commandHandler(parent, undefined, room);
            parent.commandHandlers[room] = commandHandler;
        });
    }

    updateRoomsConfig(channels){
        if (!fs.existsSync(configDir)){
            fs.mkdirSync(configDir);
        }
        jsonfile.writeFile(configDir+fileRoomsJs, channels);
    }


    startWebsockets(json) {
		//console.log("startWebsockets executing already: "+conecting);
		if (conecting == true) { return 0; }
		conecting = true;
        if (this.config.debug == "true") {
            this.ws = new WebSocket('ws://chat.f-list.net:8722');
        }
        else {
            this.ws = new WebSocket('ws://chat.f-list.net:9722');
        }

        this.ws.on('open', function(test) {
			console.log("WS open");
            parent.sendWS('IDN', json);
        });

        this.ws.on('close', function(test) {
            console.log("WS close");
			clearInterval(pingInterval);
			setTimeout(parent.connect, 15000);
			conecting = false;
        });

        this.ws.on('error', function(test) {
            console.log("WS error");
			clearInterval(pingInterval);
            setTimeout(parent.connect, 15000);
			conecting = false;
        });

        this.ws.on('message', function (data, flags) {
			//console.log("<< "+data);
            clearInterval(pingInterval);
			pingInterval = setInterval(function () { console.log("The server has taken more than 40 seconds to send any messages, attempting to reconnect"); parent.ws.close(); }, 40000);
            if (data != null) {
                this.command = this.argument = "";
                this.command = splitOnce(data, " ")[0].trim();
                try{
                    this.argument = JSON.parse(data.substring(this.command.length).trim());
                }
                catch (e) {
                }
                switch (this.command) {
                    case "CON":
                        for (var i in parent.connectionListeners) {
                            parent.connectionListeners[i](parent, this.argument);
                        }
                        break;
					case "ICH":
                        for (var i in parent.initialChannelDataListeners) {
                            parent.initialChannelDataListeners[i](parent, this.argument);
                        }
                        break;
                    case "JCH":
                        for (var i in parent.joinListeners) {
                            parent.joinListeners[i](parent, this.argument);
                        }
						parent.joinListener(this.argument);
                        break;
					case "LCH":
                        for (var i in parent.leaveListeners) {
                            parent.leaveListeners[i](parent, this.argument);
                        }
						parent.leaveListener(this.argument);
                        break;
					case "FLN":
                        for (var i in parent.leaveListeners) {
                            parent.leaveListeners[i](parent, this.argument);
                        }
						this.argument.channel = "meow meow";
						parent.leaveListener(this.argument);
                        break;
                    case "PIN":
                        parent.ws.send("PIN");
						//console.log(">> PIN");
						break;
                    case "PRI": //PRI { "character": string, "message": string }
                        for (var i in parent.privateMessageListeners) {
							this.argument.publico = false;
                            parent.privateMessageListeners[i](parent, this.argument);
                        }
						log.pri(this.argument.character + ": " + this.argument.message);
                        break;
                    case "MSG": //MSG { "character": string, "message": string, "channel": string }
                        for (var i in parent.messageListeners) {
							this.argument.publico = true;
                            parent.messageListeners[i](parent, this.argument, this.argument.channel);
                        }
						log.msg(this.argument.character + ": " + this.argument.message);
                        break;
					case "ERR":
						log.error("Number: "+this.argument.number+", Message: "+this.argument.message);
						break;
                }
            }
        });
    }
}

function splitOnce(str, delim) {
    var components = str.split(delim);
    var result = [components.shift()];
    if (components.length) {
        result.push(components.join(delim));
    }
    return result;
}

module.exports = FChatLib;